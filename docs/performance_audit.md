### Аудит производительности и кода (SpeedWorkshopAndroid)

#### Краткая реконструкция логики

- **Каталог**: `CatalogFragment` отображает сетку товаров (`RecyclerView` + `GridLayoutManager`), поиск, pull‑to‑refresh и пагинацию. Плейсхолдеры‑скелетоны и отдельный «loading» айтем. `CatalogPresenter` (синглтон) хранит кэш списка и управляет загрузкой. Картинки грузятся Glide в `ProductAdapter`.
- **Детали товара**: `ProductDetailFragment` показывает скелетон, пытается загрузить детали через `ProductService`, при ошибке использует данные из аргументов либо sample‑данные. Галерея на `ViewPager2` + Glide.
- **Сеть**: `HttpClient` на OkHttp, синхронный `execute()` внутри `withContext(Dispatchers.IO)`, парсинг JSON через Gson. HTTP‑кеш не включён. В зависимостях есть Cronet/Retrofit, но фактически используется ручной клиент.

### 1) Текущие малопроизводительные места

- **JSON‑парсинг на главном потоке**
  - `HttpClient.request(...)` вызывает `gson.fromJson(...)` из контекста вызова (в каталоге это `Dispatchers.Main`). Большие ответы блокируют UI.

- **Поиск/фильтрация без дебаунса на UI‑нити**
  - `CatalogFragment` триггерит поиск на каждый ввод; `CatalogPresenter.filterProducts` фильтрует на `Main`. На больших списках даёт микрофризы.

- **Полные пересборки списка при пагинации**
  - В `ProductAdapter.addProducts` используется `submitList(null)` → повторный `submitList(...)` и ручное восстановление позиции. Это провоцирует лишние перерасчёты/перерисовки.

- **Нагрузка от скелетон‑анимаций**
  - Для каждого саб‑вью запускается отдельная анимация с задержками. Много объектов и стартов анимаций на горячем пути.

- **Детали товара: поздний показ контента**
  - Всегда сначала попытка API, и лишь при фейле — данные из каталога. Даже если данные есть, дольше показан скелетон (хуже perceived performance).

- **Загрузка изображений без ограничения размеров**
  - Миниатюры в сетке грузятся без `override(width, height)` и оптимального downsampling — возможны дорогие декодирования больших исходников.

- **HTTP без кеша**
  - OkHttp Cache отсутствует. Повторные визиты/скролл назад требуют сетевых запросов (латентность, трафик).

- **Шумные логи на горячем пути**
  - Много `Log.d` в адаптере/презентере во время обновлений списка/пагинации.

### 2) Спорные решения в коде

- **Синглтон‑презентер с `CoroutineScope(Dispatchers.Main)`**
  - Не привязан к lifecycle. Риск висящих джоб/утечек и сложность отмены. Для этого лучше `ViewModel` + `viewModelScope`.

- **Пагинация через «очистку» списка**
  - Хрупкий трюк с `submitList(null)` + ручное восстановление позиции. Правильнее добавлять элементы к текущему списку или использовать Paging 3/`ConcatAdapter`.

- **Мутация модели в адаптере**
  - В `ProductAdapter` кликом меняется `product.isFavorite`. При `ListAdapter` это легко расходится с diff‑логикой. Лучше создавать новую копию модели и поднимать изменение в слой состояния.

- **Собственные `CoroutineScope` во фрагментах**
  - `ProductDetailFragment` создаёт `CoroutineScope(Dispatchers.Main)`. При уничтожении view работы могут продолжаться. Предпочтительно `viewLifecycleOwner.lifecycleScope`.

- **Неиспользуемые тяжёлые зависимости**
  - Подключены Cronet/Retrofit, но используется ручной OkHttp + Gson. Лишний вес и путаница.

- **Ручная сборка query‑параметров без URL‑encoding**
  - `HttpClient.buildUrlWithParams(...)` не экранирует спецсимволы — функционально и поддерживаемо спорно.

- **Release‑сборка без минификации**
  - `isMinifyEnabled = false` — не про лаги, но снижает эффективность (размер/оптимизации).

### 3) План исправлений (приоритетно)

- **Стабильный FPS / отсутствие фризов**
  - Перенести парсинг JSON off‑main:
    - Обернуть `gson.fromJson(...)` в `withContext(Dispatchers.Default) { ... }` в `HttpClient.request`.
    - Либо перейти на Retrofit + `converter-gson` (парсинг фоновый по умолчанию, `suspend` API).
  - Ввести дебаунс поиска и фон‑фильтрацию:
    - Заменить `TextWatcher` на `Flow` с `debounce(250–350ms)` и `distinctUntilChanged()`.
    - Фильтровать на `Dispatchers.Default`, на `Main` только устанавливать результат.
  - Починить пагинацию/обновления списка:
    - Убрать `submitList(null)`. При дозагрузке делать `submitList(old + new)`.
    - Индикатор подгрузки вынести в `ConcatAdapter` или управлять им флагом без пересоздания всего списка.
    - Включить `recyclerView.setHasFixedSize(true)`.

- **Скелетоны и переходы**
  - Запускать одну «shimmer» на контейнер, а не анимации на каждый саб‑вью. Останавливать анимации в `onViewRecycled`/`onDestroyView`.
  - В `ProductDetailFragment` сначала отрисовывать данные из аргументов (если есть), параллельно подгружать детали и мягко обновлять UI.

- **Оптимизация изображений (Glide)**
  - В карточках: `override(cellWidth, cellHeight)`, `centerCrop()`, `diskCacheStrategy(AUTOMATIC)`, `thumbnail(0.25f)`.
  - В галерее: добавить `downsample(AT_MOST)` и единообразные `placeholder/error`.

- **Сетевой слой**
  - Включить OkHttp Cache (например, 10–20 МБ) и корректный `Cache-Control`/ETag, если поддерживается сервером.
  - Перейти на Retrofit (типобезопасные интерфейсы, автоматический парсинг, интерсепторы, проще тестировать) либо аккуратно добавить URL‑encoding в текущий клиент.

- **Архитектура/корутины**
  - Заменить `CatalogPresenter` на `ViewModel` и хранить состояние в репозитории/`SavedStateHandle`.
  - Во фрагментах использовать `viewLifecycleOwner.lifecycleScope` вместо собственных `CoroutineScope`.

- **Логи/сборка**
  - Снизить подробность логов на горячем пути и обернуть в Timber/`BuildConfig.DEBUG`.
  - Удалить Cronet, если не используем, либо действительно интегрировать его.
  - Включить `minifyEnabled true` и `shrinkResources true` в release.

#### Быстрые выигрыши (можно сделать сразу)

- Обернуть `gson.fromJson` в `withContext(Dispatchers.Default)`.
- Дебаунс поиска и фильтрация на `Dispatchers.Default`.
- Убрать `submitList(null)` и добавлять в конец текущего списка.
- Включить OkHttp Cache и URL‑encoding параметров.
- Перейти на `viewLifecycleOwner.lifecycleScope` в фрагментах.
- Добавить `override/centerCrop/diskCacheStrategy` в Glide для карточек.

### 4) Выполненные оптимизации

#### Архитектурные улучшения

- **Переход от MVP к MVVM**
  - Заменили синглтон-презентер на `CatalogViewModel` с привязкой к жизненному циклу фрагмента
  - Состояние избранных товаров теперь хранится в `MutableStateFlow` в ViewModel
  - Добавили `CatalogViewModelFactory` для внедрения зависимостей

- **Пагинация с Paging 3**
  - Внедрили AndroidX Paging 3 вместо ручной пагинации
  - Создали `ProductsPagingSource` для загрузки данных
  - Заменили `ProductAdapter` на `ProductPagingAdapter` с поддержкой `PagingDataAdapter`
  - Добавили `ProductsLoadStateAdapter` для отображения состояний загрузки

- **Улучшенное управление жизненным циклом**
  - Заменили `launchWhenStarted` на `repeatOnLifecycle(Lifecycle.State.STARTED)` для безопасного сбора Flow
  - Перешли с собственных `CoroutineScope` на `viewLifecycleOwner.lifecycleScope`
  - Добавили корректную очистку ресурсов в `onDestroyView`

#### Оптимизации производительности

- **Сетевой слой**
  - Перенесли парсинг JSON с главного потока на `Dispatchers.Default`
  - Интегрировали Retrofit для типобезопасных API-вызовов
  - Добавили HTTP-кеширование (20MB) с `Cache-Control: public, max-age=60`
  - Добавили корректное URL-кодирование параметров запросов

- **UI и отзывчивость**
  - Добавили дебаунс (300мс) для поискового запроса
  - Отключили анимации элементов в RecyclerView (`itemAnimator = null`)
  - Настроили пул переиспользования вьюх (`setRecycledViewPool`, `setItemViewCacheSize(12)`)
  - Установили `setHasFixedSize(true)` для оптимизации лейаута

- **Оптимизации загрузки изображений**
  - Добавили `override(width, height)` для предотвращения декодирования больших изображений
  - Включили `centerCrop()` для быстрого масштабирования
  - Настроили `diskCacheStrategy(DiskCacheStrategy.AUTOMATIC)` для кеширования
  - Добавили `thumbnail(0.25f)` для быстрого отображения низкокачественных превью
  - Применили `downsample(DownsampleStrategy.AT_MOST)` для оптимального даунсемплинга
  - Интегрировали `recyclerview-integration` для Glide

- **Скелетоны и анимации**
  - Переработали анимацию скелетонов для лучшей производительности
  - Создали `ProductsListSkeletonView` для централизованного управления скелетонами
  - Заменили множественные анимации на одну общую пульсацию
  - Оптимизировали показ данных в деталях продукта (сначала из аргументов, затем асинхронное обновление)

#### Улучшения кода

- **Логирование**
  - Заменили `android.util.Log` на `Timber` для более эффективного логирования
  - Удалили константы `TAG` (Timber автоматически добавляет имя класса)

- **Безопасность типов**
  - Заменили небезопасные операторы `!!` на `checkNotNull()` с понятными сообщениями об ошибках

- **Чистота кода**
  - Удалили неиспользуемый код (`ProductAdapter`, `setupScrollListener`, `setupTestPagination`)
  - Удалили неиспользуемые зависимости (Cronet, lifecycle-livedata-ktx)
  - Удалили избыточные комментарии, не несущие смысловой нагрузки

- **Сборка**
  - Включили `minifyEnabled = true` и `shrinkResources = true` для релизных сборок
  - Настроили CI/CD для автоматической сборки и тестирования

#### Визуальные улучшения

- **Улучшенные индикаторы загрузки**
  - Добавили фон для футера загрузки для лучшей видимости на белом фоне
  - Улучшили отображение состояний ошибок и повторных попыток загрузки

- **Скелетоны**
  - Исправили анимацию скелетонов для соответствия оригинальному дизайну
  - Улучшили визуальное отображение пульсации

### 5) Результаты оптимизаций

- **Повышение FPS и отзывчивости UI**
  - Устранены фризы при скролле и поиске
  - Снижена нагрузка на главный поток

- **Улучшенный UX**
  - Более быстрое отображение контента (особенно при переходе к деталям продукта)
  - Более плавные анимации и переходы

- **Снижение сетевой нагрузки**
  - Кеширование HTTP-запросов
  - Оптимизированная загрузка изображений

- **Архитектурные преимущества**
  - Более поддерживаемый и тестируемый код
  - Лучшее разделение ответственности между компонентами
  - Более современная и стандартная архитектура

- **Меньший размер APK**
  - Удаление неиспользуемых зависимостей
  - Включение минификации и сжатия ресурсов

Все эти оптимизации значительно улучшили производительность приложения, особенно на устройствах среднего и низкого класса, а также создали более надежную основу для дальнейшего развития.